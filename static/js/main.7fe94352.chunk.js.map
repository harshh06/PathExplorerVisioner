{"version":3,"sources":["visualizer/Header.js","visualizer/Node.js","algorithm/bfs.js","algorithm/dijkstra.js","algorithm/astar.js","visualizer/Visualizer.js","algorithm/dfs.js","App.js","reportWebVitals.js","index.js"],"names":["Header","className","Component","Node","this","props","col","row","isStart","isEnd","isVisited","isWall","onMouseUp","onMouseDown","onMouseEnter","extendedClass","id","nodesInShortestPath","visitedNodeInOrder","finishNode","shortestPathNodes","currentNode","parentNode","unshift","dijkstra","grid","startNode","visitedcellsInOrder","distance","unvisitedcells","cells","node","push","getAllcells","length","sortcellsByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","AStar","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","sortByDistance","distanceToFinishNode","Visualizer","InitialTable","rows","state","numOfRows","cols","numOfColumns","initialTable","i","j","createNode","isStartNode","startNodeCol","endNodeRow","isEndNode","endNodeCol","isNode","Math","abs","startNodeRow","isRunning","isMousePressed","isWallNode","currRow","currCol","handleMouseDown","bind","handleMouseLeave","setState","newGrid","slice","nodeClassName","document","getElementById","previousNode","isGridClear","getNewGridWithWallToggled","clearGrid","shortestPathNodeInOrder","setTimeout","animateShortestPath","nodesInShortestPathOrder","toggleIsRunning","algorithm","beginningNode","enddingNode","nextNodesStack","nextNode","bfs","animateBFS","console","log","pop","dfs","onClick","visualize","onMouseLeave","map","rowId","cell","cellId","handleMouseEnter","handleMouseUp","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.7fe94352.chunk.js","sourcesContent":["// Displays the header for the site ..\nimport React, { Component } from \"react\";\nimport \"./Visualizer.css\";\n\nexport default class Header extends Component {\n  render() {\n    return (\n      <div className=\"main-header\">\n        <div className=\"container\">\n          <h1>Path Finding Visualizer</h1>\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { Component } from \"react\";\nimport \"./Node.css\";\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isStart,\n      isEnd,\n      isVisited,\n      isWall,\n      onMouseUp,\n      onMouseDown,\n      onMouseEnter,\n    } = this.props;\n\n    const extendedClass = isStart\n      ? \"startNode\"\n      : isEnd\n      ? \"endNode\"\n      : isVisited\n      ? \"node-visited\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <td\n        id={`node-${row}-${col}`}\n        className={`node ${extendedClass}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></td>\n    );\n  }\n}\n","export function bfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [startNode];\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.shift();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n  // return visitedNodesInOrder;\n}\n\nexport function nodesInShortestPath(visitedNodeInOrder, finishNode) {\n  let shortestPathNodes = [];\n  let currentNode = finishNode;\n  while (currentNode.parentNode != null) {\n    shortestPathNodes.unshift(currentNode);\n    currentNode = currentNode.parentNode;\n  }\n  return shortestPathNodes;\n}\n","export function dijkstra(grid, startNode, finishNode) {\n  const visitedcellsInOrder = [];\n  startNode.distance = 0;\n  const unvisitedcells = getAllcells(grid); // Q: different from using grid or slice of grid???\n\n  while (unvisitedcells.length) {\n    sortcellsByDistance(unvisitedcells);\n    const closestNode = unvisitedcells.shift();\n    // If we encounter a wall, we skip it.\n    if (!closestNode.isWall) {\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should stop.\n      if (closestNode.distance === Infinity) return visitedcellsInOrder;\n      closestNode.isVisited = true;\n      visitedcellsInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedcellsInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction getAllcells(grid) {\n  const cells = [];\n  for (const row of grid) {\n    for (const node of row) {\n      cells.push(node);\n    }\n  }\n  return cells;\n}\n\nfunction sortcellsByDistance(unvisitedcells) {\n  unvisitedcells.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.parentNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","export function AStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid); // Q: different from using grid or slice of grid???\n\n  while (unvisitedNodes.length) {\n    sortByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (!closestNode.isWall) {\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nfunction sortByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1 + neighbor.distanceToFinishNode;\n    neighbor.parentNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node\";\nimport \"./Visualizer.css\";\nimport { bfs, nodesInShortestPath } from \"../algorithm/bfs\";\nimport { dfs } from \"../algorithm/dfs\";\nimport { dijkstra } from \"../algorithm/dijkstra\";\nimport { AStar } from \"../algorithm/astar\";\n//import { getElementError } from \"@testing-library/react\";\n\nexport default class Visualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      nodes: [],\n      numOfRows: 20,\n      numOfColumns: 40,\n      endNodeRow: 5,\n      startNodeRow: 5,\n      endNodeCol: 30,\n      startNodeCol: 5,\n      isRunning: false,\n      isStartNode: false,\n      isEndNode: false,\n      isMousePressed: false,\n      isWallNode: false,\n      currRow: 0,\n      currCol: 0,\n    };\n\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    //this.toggleIsRunning = this.toggleIsRunning.bind(this);\n  }\n  // Grid Formation begin ..\n  componentDidMount() {\n    const nodes = this.InitialTable();\n    this.setState({\n      nodes,\n    });\n  }\n\n  // toggleIsRunning() {\n  //   this.setState({ isRunning: !this.state.isRunning });\n  // }\n\n  InitialTable = () => {\n    const rows = this.state.numOfRows;\n    const cols = this.state.numOfColumns;\n    const initialTable = [];\n    for (let i = 0; i < rows; i++) {\n      const row = [];\n      for (let j = 0; j < cols; j++) {\n        row.push(this.createNode(i, j));\n      }\n      initialTable.push(row);\n    }\n    //console.log(document.getElementById(`node-${nodes[5]}-${5}`));\n    return initialTable;\n  };\n\n  createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStartNode:\n        col === this.state.startNodeCol && row === this.state.endNodeRow,\n      isEndNode: col === this.state.endNodeCol && row === this.state.endNodeRow,\n      isVisited: false,\n      parentNode: null,\n      isNode: true,\n      isWall: false,\n      distance: Infinity,\n      distanceToFinishNode:\n        Math.abs(this.state.endNodeRow - row) +\n        Math.abs(this.state.endNodeCol - col),\n    };\n  };\n  //grid Formation ends...\n\n  // clear grid ...\n\n  clearGrid() {\n    if (!this.state.isRunning) {\n      const newGrid = this.state.nodes.slice();\n      for (const row of newGrid) {\n        for (const node of row) {\n          let nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node startNode\" &&\n            nodeClassName !== \"node endNode\" &&\n            nodeClassName !== \"node node-wall\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node\";\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.endNodeRow - node.row) +\n              Math.abs(this.state.endNodeCol - node.col);\n          }\n          if (nodeClassName === \"node node-finish\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode = 0;\n          }\n          if (nodeClassName === \"node node-start\") {\n            node.isVisited = false;\n            node.distance = Infinity;\n            node.distanceToFinishNode =\n              Math.abs(this.state.endNodeRow - node.row) +\n              Math.abs(this.state.endNodeCol - node.col);\n            node.isStart = true;\n            node.isWall = false;\n            node.previousNode = null;\n            node.isNode = true;\n          }\n        }\n      }\n    }\n  }\n\n  // end clear grid finction\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({ isStartNode, isMousePressed: false });\n    } else if (this.state.isEndNode) {\n      const isEndNode = !this.state.isEndNode;\n      this.setState({ isEndNode, isMousePressed: false });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({ isWallNode, isMousePressed: false });\n      this.InitialTable();\n    }\n  }\n\n  handleMouseDown(row, col) {\n    if (!this.state.isRunning) {\n      if (this.isGridClear()) {\n        if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node startNode\"\n        ) {\n          this.setState({\n            isMousePressed: true,\n            isStartNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else if (\n          document.getElementById(`node-${row}-${col}`).className ===\n          \"node endNode\"\n        ) {\n          this.setState({\n            isMousePressed: true,\n            isEndNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        } else {\n          const newGrid = getNewGridWithWallToggled(this.state.nodes, row, col);\n          this.setState({\n            nodes: newGrid,\n            isMousePressed: true,\n            isWallNode: true,\n            currRow: row,\n            currCol: col,\n          });\n        }\n      } else {\n        this.clearGrid();\n      }\n    }\n  }\n\n  isGridClear() {\n    for (const row of this.state.nodes) {\n      for (const node of row) {\n        const nodeClassName = document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className;\n        if (\n          nodeClassName === \"node node-visited\" ||\n          nodeClassName === \"node node-shortest-path\"\n        ) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.isRunning) {\n      if (this.state.isMousePressed) {\n        const nodeClassName = document.getElementById(`node-${row}-${col}`)\n          .className;\n        if (this.state.isStartNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevStartNode = this.state.nodes[this.state.currRow][\n              this.state.currCol\n            ];\n            prevStartNode.isStart = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`\n            ).className = \"node\";\n\n            this.setState({ currRow: row, currCol: col });\n            const currStartNode = this.state.nodes[row][col];\n            currStartNode.isStart = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              \"node startNode\";\n          }\n          this.setState({ startNodeRow: row, startNodeCol: col });\n        } else if (this.state.isEndNode) {\n          if (nodeClassName !== \"node node-wall\") {\n            const prevFinishNode = this.state.nodes[this.state.currRow][\n              this.state.currCol\n            ];\n            prevFinishNode.isEnd = false;\n            document.getElementById(\n              `node-${this.state.currRow}-${this.state.currCol}`\n            ).className = \"node\";\n\n            this.setState({ currRow: row, currCol: col });\n            const currFinishNode = this.state.nodes[row][col];\n            currFinishNode.isEnd = true;\n            document.getElementById(`node-${row}-${col}`).className =\n              \"node endNode\";\n          }\n          this.setState({ endNodeRow: row, startNodeCol: col });\n        } else if (this.state.isWall) {\n          const newGrid = getNewGridWithWallToggled(this.state.nodes, row, col);\n          this.setState({ nodes: newGrid });\n        }\n      }\n    }\n  }\n\n  handleMouseUp(row, col) {\n    if (!this.state.isRunning) {\n      this.setState({ isMousePressed: false });\n      if (this.state.isStartNode) {\n        const isStartNode = !this.state.isStartNode;\n        this.setState({ isStartNode, startNodeRow: row, startNodeCol: col });\n      } else if (this.state.isEndNode) {\n        const isEndNode = !this.state.isEndNode;\n        this.setState({\n          isEndNode,\n          endNodeRow: row,\n          endNodeCol: col,\n        });\n      }\n      this.InitialTable();\n    }\n  }\n\n  handleMouseLeave() {\n    if (this.state.isStartNode) {\n      const isStartNode = !this.state.isStartNode;\n      this.setState({ isStartNode, isMousePressed: false });\n    } else if (this.state.isEndNode) {\n      const isEndNode = !this.state.isEndNode;\n      this.setState({ isEndNode, isMousePressed: false });\n    } else if (this.state.isWallNode) {\n      const isWallNode = !this.state.isWallNode;\n      this.setState({ isWallNode, isMousePressed: false });\n      this.InitialTable();\n    }\n  }\n\n  // visualizing part begins...\n\n  animateBFS(visitedNodesInOrder, shortestPathNodeInOrder) {\n    //console.log(visitedNodesInOrder.length);\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        setTimeout(() => {\n          this.animateShortestPath(shortestPathNodeInOrder);\n        }, 15 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        //console.log(node.row);\n        if (\n          !(\n            document.getElementById(`node-${node.row}-${node.col}`)\n              .className === \"node startNode\"\n          ) &&\n          !(\n            document.getElementById(`node-${node.row}-${node.col}`)\n              .className === \"node endNode\"\n          )\n        )\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-visited\";\n      }, 10 * i);\n    }\n  }\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length - 1; i++) {\n      if (nodesInShortestPathOrder[i] === \"end\") {\n        setTimeout(() => {\n          this.toggleIsRunning();\n        }, i * 50);\n      } else {\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          const nodeClassName = document.getElementById(\n            `node-${node.row}-${node.col}`\n          ).className;\n          if (\n            nodeClassName !== \"node node-start\" &&\n            nodeClassName !== \"node node-finish\"\n          ) {\n            document.getElementById(`node-${node.row}-${node.col}`).className =\n              \"node node-shortest-path\";\n          }\n        }, i * 40);\n      }\n    }\n  }\n\n  visualize(algorithm) {\n    const {\n      nodes,\n      startNodeRow,\n      startNodeCol,\n      endNodeRow,\n      endNodeCol,\n    } = this.state;\n    const beginningNode = nodes[startNodeRow][startNodeCol];\n    //console.log(beginningNode);\n    const enddingNode = nodes[endNodeRow][endNodeCol];\n    if (algorithm === \"bfs\") {\n      let visitedNodeInOrder = bfs(nodes, beginningNode, enddingNode);\n      let shortestPathNodeInOrder = nodesInShortestPath(\n        visitedNodeInOrder,\n        enddingNode\n      );\n      this.animateBFS(visitedNodeInOrder, shortestPathNodeInOrder);\n      console.log(shortestPathNodeInOrder.length);\n    } else if (algorithm === \"dfs\") {\n      let visitedNodeInOrder = dfs(nodes, beginningNode, enddingNode);\n      let shortestPathNodeInOrder = nodesInShortestPath(\n        visitedNodeInOrder,\n        enddingNode\n      );\n      this.animateBFS(visitedNodeInOrder, shortestPathNodeInOrder);\n      console.log(shortestPathNodeInOrder.length);\n    } else if (algorithm === \"dijkstra\") {\n      let visitedNodeInOrder = dijkstra(nodes, beginningNode, enddingNode);\n      let shortestPathNodeInOrder = nodesInShortestPath(\n        visitedNodeInOrder,\n        enddingNode\n      );\n      this.animateBFS(visitedNodeInOrder, shortestPathNodeInOrder);\n      console.log(shortestPathNodeInOrder.length);\n    } else if (algorithm === \"astar\") {\n      let visitedNodeInOrder = AStar(nodes, beginningNode, enddingNode);\n      console.log(visitedNodeInOrder.length);\n      let shortestPathNodeInOrder = nodesInShortestPath(\n        visitedNodeInOrder,\n        enddingNode\n      );\n      this.animateBFS(visitedNodeInOrder, shortestPathNodeInOrder);\n      console.log(shortestPathNodeInOrder.length);\n    }\n  }\n\n  // visualization ends ..\n\n  render() {\n    const { nodes } = this.state;\n    return (\n      <div>\n        <button\n          onClick={() => {\n            this.visualize(\"bfs\");\n          }}\n          id=\"visualize-btn\"\n          className=\"btn btn-success\"\n        >\n          {\" \"}\n          BFS{\" \"}\n        </button>\n        <button\n          onClick={() => {\n            this.visualize(\"dfs\");\n          }}\n          id=\"visualize-btn\"\n          className=\"btn btn-success\"\n        >\n          {\" \"}\n          DFS{\" \"}\n        </button>\n        <button\n          onClick={() => {\n            this.visualize(\"dijkstra\");\n          }}\n          id=\"visualize-btn\"\n          className=\"btn btn-success\"\n        >\n          {\" \"}\n          Dijkstra{\" \"}\n        </button>\n        <button\n          onClick={() => {\n            this.visualize(\"astar\");\n          }}\n          id=\"visualize-btn\"\n          className=\"btn btn-success\"\n        >\n          {\" \"}\n          A*{\" \"}\n        </button>\n        <button\n          onClick={() => {\n            this.clearGrid();\n          }}\n          id=\"visualize-btn\"\n          className=\"btn btn-success\"\n        >\n          {\" \"}\n          Clear grid{\" \"}\n        </button>\n        <table\n          className=\"grid-container\"\n          onMouseLeave={() => this.handleMouseLeave()}\n        >\n          <tbody>\n            {nodes.map((row, rowId) => {\n              return (\n                <tr key={rowId}>\n                  {row.map((cell, cellId) => {\n                    const {\n                      row,\n                      col,\n                      isVisited,\n                      isStartNode,\n                      isEndNode,\n                      isWall,\n                      isMousePressed,\n                    } = cell;\n                    return (\n                      <Node\n                        key={cellId}\n                        row={row}\n                        col={col}\n                        isVisited={isVisited}\n                        isStart={isStartNode}\n                        isEnd={isEndNode}\n                        isMousePressed={isMousePressed}\n                        isWall={isWall}\n                        onMouseEnter={(row, col) =>\n                          this.handleMouseEnter(row, col)\n                        }\n                        onMouseUp={() => this.handleMouseUp(row, col)}\n                        onMouseDown={(row, col) =>\n                          this.handleMouseDown(row, col)\n                        }\n                      />\n                    );\n                  })}\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n\nconst getNewGridWithWallToggled = (nodes, row, col) => {\n  const newGrid = nodes.slice();\n  const node = newGrid[row][col];\n  if (!node.isStartNode && !node.isEndNode && node.isNode) {\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n  }\n  return newGrid;\n};\n","export function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    if (\n      !currentNode.isWall &&\n      (currentNode.isStart || !currentNode.isVisited)\n    ) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n\n      const { col, row } = currentNode;\n      let nextNode;\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n        if (!nextNode.isVisited) {\n          nextNode.parentNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\n","import \"./App.css\";\nimport React, { Component } from \"react\";\nimport Header from \"./visualizer/Header\";\nimport Visualizer from \"./visualizer/Visualizer\";\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <Visualizer />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}